module.exports = exports = ConsoleReporter;

var noopTimer = {
    start: function() {},
    elapsed: function() {
        return 0;
    }
};

function ConsoleReporter(options) {
    var print = options.print,
        showColors = options.showColors || false,
        timer = options.timer || noopTimer,
        jasmineCorePath = options.jasmineCorePath,
        printDeprecation = options.printDeprecation || require('../lib/printDeprecation'),
        specCount,
        executableSpecCount,
        failureCount,
        failedSpecs = [],
        pendingSpecs = [],
        ansi = {
            green: '\x1B[32m',
            red: '\x1B[31m',
            yellow: '\x1B[33m',
            none: '\x1B[0m'
        },
        failedSuites = [],
        stackFilter = options.stackFilter || defaultStackFilter;

    if (options.onComplete) {
        printDeprecation('Passing in an onComplete function to the ConsoleReporter is deprecated.');
    }
    var onComplete = options.onComplete || function() {};

    this.jasmineStarted = function() {
        specCount = 0;
        executableSpecCount = 0;
        failureCount = 0;
        print("##teamcity[progressStart 'Running Jasmine Tests']");
        timer.start();
    };

    this.jasmineDone = function(result) {

        print("##teamcity[progressFinish 'Running Jasmine Tests']");
        process.exit(failureCount);

        //This doesn't seem to work. So I exit.
        onComplete(failureCount === 0);
    };
    
    this.specStarted = function(spec) {
        print("##teamcity[testStarted name='" + escapeTeamcityString(spec.description) + "' captureStandardOutput='true']");
    };

    this.specDone = function(result) {
        specCount++;

        if (result.status == 'pending') {
            pendingSpecs.push(result);
            executableSpecCount++;
            print(colored('yellow', '*'));
            return;
        }

        if (result.status == 'passed') {
            executableSpecCount++;
            print("##teamcity[testFinished name='" + escapeTeamcityString(result.description) + "']");
            return;
        }

        if (result.status == 'failed') {
            failureCount++;
            failedSpecs.push(result);
            executableSpecCount++;
            print("##teamcity[testFailed name='" + escapeTeamcityString(result.description) + "' message='" + escapeTeamcityString(result.status) + "']");
        }
    };

    this.suiteDone = function(result) {
        if (result.failedExpectations && result.failedExpectations.length > 0) {
            failureCount++;
            failedSuites.push(result);
        }
        print("##teamcity[testSuiteFinished name='" + escapeTeamcityString(result.fullName) + "']");
    };
    
    this.suiteStarted = function(suite) {
        print("##teamcity[testSuiteStarted name='" + escapeTeamcityString(suite.fullName) + "']");
    };


    return this;

    function colored(color, str) {
        return showColors ? (ansi[color] + str + ansi.none) : str;
    }

    function plural(str, count) {
        return count == 1 ? str : str + 's';
    }

    function repeat(thing, times) {
        var arr = [];
        for (var i = 0; i < times; i++) {
            arr.push(thing);
        }
        return arr;
    }

    function indent(str, spaces) {
        var lines = (str || '').split('\n');
        var newArr = [];
        for (var i = 0; i < lines.length; i++) {
            newArr.push(repeat(' ', spaces).join('') + lines[i]);
        }
        return newArr.join('\n');
    }

    function defaultStackFilter(stack) {
        var filteredStack = stack.split('\n').filter(function(stackLine) {
            return stackLine.indexOf(jasmineCorePath) === -1;
        }).join('\n');
        return filteredStack;
    }

    function specFailureDetails(result, failedSpecNumber) {
        
        print(failedSpecNumber + ') ');
        print(result.fullName);

        for (var i = 0; i < result.failedExpectations.length; i++) {
            var failedExpectation = result.failedExpectations[i];
            
            print(indent('Message:', 2));
            
            print(colored('red', indent(failedExpectation.message, 4)));
            
            print(indent('Stack:', 2));
            
            print(indent(stackFilter(failedExpectation.stack), 4));
        }
    }

    function suiteFailureDetails(result) {
        for (var i = 0; i < result.failedExpectations.length; i++) {
            
            print(colored('red', 'An error was thrown in an afterAll'));
            
            print(colored('red', 'AfterAll ' + result.failedExpectations[i].message));

        }
        
    }

    function pendingSpecDetails(result, pendingSpecNumber) {
        
        
        print(pendingSpecNumber + ') ');
        print(result.fullName);
        
        var pendingReason = "No reason given";
        if (result.pendingReason && result.pendingReason !== '') {
            pendingReason = result.pendingReason;
        }
        print(indent(colored('yellow', pendingReason), 2));
        
    }

    function escapeTeamcityString(message) {
        if (!message) {
            return "";
        }

        if (typeof(message) !== String) {
            //RRL: Ensure that messages are strings before attempting to call replace on them.
            message = String(message);
        }
        return message.replace(/\|/g, "||")
            .replace(/\'/g, "|'")
            .replace(/\n/g, "|n")
            .replace(/\r/g, "|r")
            .replace(/\u0085/g, "|x")
            .replace(/\u2028/g, "|l")
            .replace(/\u2029/g, "|p")
            .replace(/\[/g, "|[")
            .replace(/]/g, "|]");
    }
}